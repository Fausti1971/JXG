Problem:
		min- und max-Werte mancher Parameter sind von Contents anderer Values abhängig (variabel). Die aktuelle Struktur bietet keine elegante Möglichkeit, dies abzubilden.
		Beispiel: velocitylimit_?; notelimit_?;
		Andererseits würde aufgrund der Erzeugung und Bindung eines Parameters je Value Speicher verschwendet.
	Lösung:
		nicht die min- und max-Parameter sind veränderlich, sondern die Contents beider Values dürfen sich lediglich nicht überschneiden.
		Dies könnte man auch ausschließlich im Steuerelement sicherstellen, z.B. doubleSlider.
		Das hätte auch den Charme, dass die zusätzlich veränderten Contents des abhängigen Values zwar geändert, aber nicht gesendet werden müssen,
		da so lediglich das native Deviceverhalten nachgebildet wird.
Problem:
		nicht-kontinuierliche Wertebereiche können nur unzureichend durch kontinuierliche Steuerelemente, wie Knob oder Slider abgebildet werden.
	Lösung:
		Durch Einführung einer weiteren Abstraktionsstufe müssen nicht-kontinuierliche Werte auf kontinuierliche XGTables (Arrays?) abgebildet werden.
		Das würde bedeuten, dass der Conent eines XGValues nicht den reelen Wert, sondern nur den XGTableindex eines XGTableEntrys abbildet.
		Außerdem müssten dazu alle (auch kontinuierliche) Wertebereiche auf XGTables abgebildet werden, was weitere Speicherverschwendung ist.
	Lösung:
		Wenn alle Wertebereiche mittels XGTable abgebildet würden, könnte man eine Werteänderung auch über den Wertebereich der XGTable machen (lowerEntry(), higherEntry());
		Eine XGTable für den Wertebereich 0...16383 (14Bit) wäre etwa 511kB groß...
		Idee: XGVirtualTable, eine Klasse, die die benötigten Methoden einer TreeMap<Integer, XGTableEntry> nachbildet;
	gelöst: mittels XGVirtualTable;
Problem:
		zu viel Text in opcode.xml (bspw. 18 gleiche param in fast allen rev_parm für lediglich 4 verschiedene msb)
	Lösung:
		vorstellbar wäre eine mask, die dem int-key (zur speicherung in der beinaltenden map der params am opcode) mitgegeben werden könnte.
		Diese müsste beim abfragen (.get(key)) nur nach den relevanten werten maskieren. Bei einem nicht vorhandenen lsb-Eintrag müssten so nur msb und value matchen,
		um einen Treffer zu erzeugen.
	verworfen;
Problem:
		Die Vermischung von pseudostatischen Objekten (XGModule, XGBulk, XGOpcode, XGParameter) und Instanzobjekten (XGModule, XGValue) spart Speicher, verhindert aber auch klare Linie.
		Sowie auch die Vermischung von hierarchischen (XGModule, XGBulk) und flachen (XGOpcode, XGValue) Strukturen.
	Lösung:
		hierarchische Initialisierung und flache Instanzierung von XGModule, XGBulk und XGValue (anhand XGOpcode und XGParameter),
		bedeutet: Erzeugung der XGValueInstanzen während der XGopcodeinitialisierung;
		Speicherung der Referenz der XGModuleinstanz im XGBulk;
		Speicherung von Referenz der XGBulkinstanz im XGValue;
		möglicherweise keine Speicherung der XGModule im XGDevice mehr erforderlich, lediglich ModuleNameCache;
		grafische Aufbereitung im Baum dynamisch anhand XGDevice.getValues();
		Tipp: XGOpcode includiert sowohl XGAddress von XGModuleinstanz als auch XGAddress von XGBulkInstanz, somit sollte es möglich sein,
		auch im Nachgang anhand der XAddress des XGOpcode zur Initialisierung und Instanzierung der XGValuen die XGModuleInstanz bzw. XGBulkInstanz zu ermitteln
	Lösung:
		berechne Overhead bei Verzicht auf XGOpcode und Speicherung in XGValue
		oder vertraue auf die Speicheroptimierung von Java...
	gelöst: ungeachtet der Speicherverschwendung wird im Zuge der XGModule- und XGBulkDump-Initialisierung und -Instanzierung für jede XGValueInstanz eine XGOpcodeInstanz
		erzeugt und im XGValue gesichert mit offenbar überschaubarem Qverhead. Vielleicht kann man mittels hashcode() und equals() noch etwas optimieren...
Problem:
		Aufgrund der Reduktion des XGSuperModule auf reine Module-Instanzen und dem vollständigen Verzicht auf MVC ergibt sich das Problem, dass XGModule nicht mehr geschachtelt werden können.
	Lösung: Umsetzung MVC
	Lösung: Wiedereinführung der hierarchischen Struktur von XGModule, was den Charme hat,
		dass auch "Folder" vom Type XGModule sind und somit mit Bedeutung (vielleicht sogar mit eigenem XGTemplate) versehen werden können.
		Ursprung des Einführung der rein instanzbasierten XGModule war die Anforderung, dem XGValue seine XGModuleinstanz bekannt zu machen um Actions,
		wie z.b. "request_module" zu automatisieren. siehe oben (grafische Aufbereitung im Baum...)
Problem:
		kein Problem, eher ein Streben nach Klarheit...
	Lösung: Einführung von globalen, konfigurierbaren XGVariablen (z.B. multipart, adpart, drumset, drum...). Könnte eine um einen Namen und eine Translation erweitertes XGAddressField sein.
		<variable tag="mp" name="Multipart" min="0" max="31" table="multipart">
		<variable tag="ds" name="Drumset" min="48" max="51" table="notes">
		...
Problem:
		kein Problem, eher anderes Konzept:
		Eine Programmistanz pro Device wäre möglich durch Übergabe (arg]0]) des Devicekonfigurationspfades beim Start (/home/user/JXG/MU80/0) in dem die Devicekonfiguration (config.xml)
		gespeichert würde, wobei der optionale Ordner (0) die SysexID bestimmt, damit mehrere Devices selben Typs editiert werden können. Beim Fehlen des Pfades könnte man als default XG benutzen.
		Die Devicekonfiguration könnte auch komplett auf XG basieren und sich lediglich auf die Aufzählung der unterstützen Opcodes, Bulks, Drumsets, ADParts usw. bzw. deren Anzahl beschränken.
		Außerdem könnte man diese unterstützten Elemente auch automatisch erfragen lassen...
		Eventuell auch möglich für Tables: Generiere devicespezifische Table durch senden, erfragen, vergleichen und speichern von PrgChangemeldungen (erfolglos getestet; verworfen)
		(zum aussondern von doppelten Einträgen könnte man über eine DBMS nachdenken)
		Denke nochmals über DBMS und FX nach...
Problem:
		der komplette (bislang sequentielle) Request dauert beim MU80 über eine Minute. Insbesondere durch den Verzicht auf die Mitführung der defaults dauert das z.B. beim Wechsel eines
		Drumsets zu lange. Denke also wieder über eine RequestQueue nach (mit all ihren durch Threading entstehenden Komplexitäten).
		Erreichbar über die Erweiterung der XGMessenger-Schnittstelle (request(Set<XGRequest>)/submit(Set<XGResponse>)), im Messenger konkret über eine In- und OutQueue.
		Geht vielleicht auch ohne Threading, indem man des Programm warten lässt bis alle Reuests versendet oder gar beantwortet wurden.
		Die Möglichkeit des sequentiellen Requests muss aber erhalten bleiben für bspw. requestInfo().
		Das unermittelte "Raushauen" aller Requests quittiert (nur) der MU80 mit "Illegal Data!" und massiven Verlusten - also unpraktikabel, weiter sequentiell...
		nach Umstellung des DumpIntervall am MU80 auf 50 ms dauert der komplette Request ca. 30 s, ein Drumset-Request ca 6 s;
		Alternativ könnte man über die Pflege von Defaultwerten sinnieren.
Problem:
		nachdem die Statusbar indirekt vom EDT aktualisiert wird, rückt nun auch hier das leidige Threading näher. Konzept überdenken bezüglich XGMidi.requestThread.interrupt();